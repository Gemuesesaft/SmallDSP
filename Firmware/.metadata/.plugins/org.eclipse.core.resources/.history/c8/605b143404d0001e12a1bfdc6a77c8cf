/**
 ******************************************************************************
 * @file    AK4619.c
 * @version 1.0
 * @author  Till Heuer
 * @brief   Driver for AKM AK4619 4 channel audio codec.
 * @date 	Feb 20, 2024
 ******************************************************************************
 */

/** @addtogroup IC_Drivers
 * @{
 */

/** @addtogroup Audio_Codec
 * @{
 */

#include <AK4619.h>

uint8_t AK4619_ActivateSPIComunication(ak4619_Device_t *device) {
	uint8_t spiData[4] = {0xDE, 0xAD, 0xDA, 0x7A};

	/* Holds hal status for error catching. */
	uint8_t status = 0;

	/* Checks for input errors. */
	if(device->mcuInterface != ak4619_SPI) {
		return HAL_ERROR;
	}

	/* Repeats spi call, in case of busy spi unit. */
	for(uint8_t attempt = 0; attempt <= AK4619_COM_MAX_ATTEMPTS; attempt++) {
		/* Reads current setting of register. */
		HAL_GPIO_WritePin(device->NCSPort, device->NCSPin, GPIO_PIN_RESET);
		status = HAL_SPI_Transmit(device->hspi, spiData, 4, AK4619_COM_TIMEOUT);
		HAL_GPIO_WritePin(device->NCSPort, device->NCSPin, GPIO_PIN_SET);
		if(status == HAL_OK) {
			/* Breaks out of loop when successful. */
			break;
		} else if(status == HAL_ERROR) {
			/* Returns error when spi unit fails. */
			return HAL_ERROR;
		} else {
			/* Delays next spi call if first attempt failed. */
			HAL_Delay(AK4619_SPI_ATTEMPT_DELAY);
		}
	}

	/* Catches case when all attempts failed and returns last error code. */
	if(status > HAL_OK) {
		return status;
	}

	return EXIT_SUCCESS;
}

uint8_t AK4619_WriteSPI(ak4619_Device_t *device, uint8 registerAddress, uint8_t data) {
	uint8_t spiData[4] = {0xC3, 0x00, 0x00, 0x00};

	/* Holds hal status for error catching. */
	uint8_t status = 0;

	/* Checks for input errors. */
	if(device->mcuInterface != ak4619_SPI) {
		return HAL_ERROR;
	}

	spiData[2] = registerAddress;
	spiData[3] = data;

	/* Repeats spi call, in case of busy spi unit. */
	for(uint8_t attempt = 0; attempt <= AK4619_COM_MAX_ATTEMPTS; attempt++) {
		/* Reads current setting of register. */
		HAL_GPIO_WritePin(device->NCSPort, device->NCSPin, GPIO_PIN_RESET);
		status = HAL_SPI_Transmit(device->hspi, spiData, 4, AK4619_COM_TIMEOUT);
		HAL_GPIO_WritePin(device->NCSPort, device->NCSPin, GPIO_PIN_SET);
		if(status == HAL_OK) {
			/* Breaks out of loop when successful. */
			break;
		} else if(status == HAL_ERROR) {
			/* Returns error when spi unit fails. */
			return HAL_ERROR;
		} else {
			/* Delays next spi call if first attempt failed. */
			HAL_Delay(AK4619_SPI_ATTEMPT_DELAY);
		}
	}

	/* Catches case when all attempts failed and returns last error code. */
	if(status > HAL_OK) {
		return status;
	}

	return EXIT_SUCCESS;
}

uint8_t AK4619_ReadSPI(ak4619_Device_t *device, uint8 registerAddress, uint8_t *data) {
	uint8_t spiData[3] = {0x43, 0x00, 0x00};

	/* Holds hal status for error catching. */
	uint8_t halStatus = 0;

	/* Checks for input errors. */
	if(device->mcuInterface != ak4619_SPI) {
		return HAL_ERROR;
	}

	spiData[2] = registerAddress;

	/* Repeats spi call, in case of busy spi unit. */
	for(uint8_t attempt = 0; attempt <= AK4619_COM_MAX_ATTEMPTS; attempt++) {
		/* Reads current setting of register. */
		HAL_GPIO_WritePin(device->NCSPort, device->NCSPin, GPIO_PIN_RESET);
		halStatus = HAL_SPI_TransmitReceive(device->hspi, spiData, data, 4, AK4619_COM_TIMEOUT);
		HAL_GPIO_WritePin(device->NCSPort, device->NCSPin, GPIO_PIN_SET);
		if(halStatus == HAL_OK) {
			/* Breaks out of loop when successful. */
			break;
		} else if(halStatus == HAL_ERROR) {
			/* Returns error when spi unit fails. */
			return HAL_ERROR;
		} else {
			/* Delays next spi call if first attempt failed. */
			HAL_Delay(AK4619_SPI_ATTEMPT_DELAY);
		}
	}

	/* Catches case when all attempts failed and returns last error code. */
	if(halStatus > HAL_OK) {
		return halStatus;
	}

	return EXIT_SUCCESS;
}

uint8_t AK4619_WriteI2C(ak4619_Device_t *device, uint8 registerAddress, uint8_t data) {
	uint8_t status = 0; // Holds i2c status for error catching.

	/* Checks for input errors. */
	if(device->mcuInterface != ak4619_I2C) {
		return HAL_ERROR;
	}

	/* Repeats i2c call, in case of busy i2c unit. */
	for(uint8_t attempt = 0; attempt <= AK4619_COM_MAX_ATTEMPTS; attempt++) {
		status = HAL_I2C_Mem_Write(device->hi2c, (AK4619_I2C_DEVICE_ADDRESS + device->a0) << 1, registerAddress, I2C_MEMADD_SIZE_8BIT, &data, 1, AK4619_COM_TIMEOUT);
		if(halStatus == HAL_OK) { // Breaks out of loop when successful.
			break;
		} else if(status == HAL_ERROR) { // Returns error when i2c unit fails.
			return HAL_ERROR;
		} else {
			/* Delays next i2c call if first attempt failed. */
			HAL_Delay(AK4619_I2C_ATTEMPT_DELAY);
		}
	}

	/* Catches case when all attempts failed and returns last error code. */
	if(status > HAL_OK) {
		return status;
	}

	return EXIT_SUCCESS;
}

uint8_t AK4619_ReadI2C(ak4619_Device_t *device, uint8 registerAddress, uint8_t *data) {
	uint8_t status = 0; // Holds i2c status for error catching.

	/* Checks for input errors. */
	if(device->mcuInterface != ak4619_I2C) {
		return HAL_ERROR;
	}

	/* Repeats i2c call, in case of busy i2c unit. */
	for(uint8_t attempt = 0; attempt <= AK4619_COM_MAX_ATTEMPTS; attempt++) {
		status = HAL_I2C_Mem_Read(device->hi2c, (AK4619_I2C_DEVICE_ADDRESS + device->a0) << 1, registerAddress, I2C_MEMADD_SIZE_8BIT, &data, 1, AK4619_COM_TIMEOUT);
		if(halStatus == HAL_OK) { // Breaks out of loop when successful.
			break;
		} else if(status == HAL_ERROR) { // Returns error when i2c unit fails.
			return HAL_ERROR;
		} else {
			/* Delays next i2c call if first attempt failed. */
			HAL_Delay(AK4619_I2C_ATTEMPT_DELAY);
		}
	}

	/* Catches case when all attempts failed and returns last error code. */
	if(status > HAL_OK) {
		return status;
	}

	return EXIT_SUCCESS;
}

uint8_t AK4619_Init(ak4619_Device_t *device) {
	uint8_t status = 0;
	if(device->mcuInterface == ak4619_SPI) {
		status = AK4619_ActivateSPIComunication(device);
		if(status) return EXIT_FAILURE;
	} else if(device->mcuInterface != ak4619_I2C) {
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

uint8_t AK4619_SetPowerManagementRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetManagementRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetAudioInterfaceFormatRegister(ak4619_Device_t *device, uint16_t registerValue);
uint8_t AK4619_GetAudioInterfaceFormatRegister(ak4619_Device_t *device, uint16_t *registerValue);
uint8_t AK4619_SetSystemClockRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetSystemClockRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetMicAmpRegister(ak4619_Device_t *device, uint16_t registerValue);
uint8_t AK4619_GetMicAmpRegister(ak4619_Device_t *device, uint16_t *registerValue);
uint8_t AK4619_SetADCDigitalVolumeRegister(ak4619_Device_t *device, uint32_t registerValue);
uint8_t AK4619_GetADCDigitalVolumeRegister(ak4619_Device_t *device, uint32_t *registerValue);
uint8_t AK4619_SetADCDigitalFilterRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetADCDigitalFilterRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetADCAnalogInputRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetADCAnalogInputRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetADCMuteAndHPFControlRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetADCMuteAndHPFControlRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetDACDigitalVolumeRegister(ak4619_Device_t *device, uint32_t registerValue);
uint8_t AK4619_GetDACDigitalVolumeRegister(ak4619_Device_t *device, uint32_t *registerValue);
uint8_t AK4619_SetDACInputSettingsRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetDACInputSettingsRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetDACDeemphasisRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetDACDeemphasisRegister(ak4619_Device_t *device, uint8_t *registerValue);
uint8_t AK4619_SetDACMuteAndFilterSettingsRegister(ak4619_Device_t *device, uint8_t registerValue);
uint8_t AK4619_GetDACMuteAndFilterSettingsRegister(ak4619_Device_t *device, uint8_t *registerValue);

uint8_t AK4619_SetPowerSetting(ak4619_Device_t *device, ak4619_Converter_t converter, ak4619_PowerMode_t powerMode);
uint8_t AK4619_GetPowerSetting(ak4619_Device_t *device, ak4619_Converter_t converter, ak4619_PowerMode_t *powerMode);
uint8_t AK4619_SetResetMode(ak4619_Device_t *device, ak4619_ResetMode_t resetMode);
uint8_t AK4619_GetResetMode(ak4619_Device_t *device, ak4619_ResetMode_t *resetMode);
uint8_t AK4619_SetTDMMOde(ak4619_Device_t *device, ak4619_TDMMode_t tdmMode);
uint8_t AK4619_GetTDMMode(ak4619_Device_t *device, ak4619_TDMMode_t *tdmMode);
uint8_t AK4619_SetAudioInterfaceFormat(ak4619_Device_t *device, ak4619_AudioInterfaceFormat_t intFormat);
uint8_t AK4619_GetAudioInterfaceFormat(ak4619_Device_t *device, ak4619_AudioInterfaceFormat_t *intFormat);
uint8_t AK4619_SetSlotLength(ak4619_Device_t *device, ak4619_WordLength_t slotLength);
uint8_t AK4619_GetSlotLength(ak4619_Device_t *device, ak4619_WordLength_t *slotLength);
uint8_t AK4619_SetBCLKEdge(ak4619_Device_t *device, ak4619_BCLKEdge_t bclkEdge);
uint8_t AK4619_GetBCLKEdge(ak4619_Device_t *device, ak4619_BCLKEdge_t *bclkEdge);
uint8_t AK4619_SetFastModeSetting(ak4619_Device_t *device, ak4619_SDOUTFastMode_t fastMode);
uint8_t AK4619_GetFastModeSetting(ak4619_Device_t *device, ak4619_SDOUTFastMode_t *fastMode);
uint8_t AK4619_SetSlotStart(ak4619_Device_t *device, ak4619_SlotStartPosition_t slotStart);
uint8_t AK4619_GetSlotStart(ak4619_Device_t *device, ak4619_SlotStartPosition_t *slotStart);
uint8_t AK4619_SetADCWordLength(ak4619_Device_t *device, ak4619_WordLength_t wordLength);
uint8_t AK4619_GetADCWordLength(ak4619_Device_t *device, ak4619_WordLength_t *wordLength);
uint8_t AK4619_SetDACWordLength(ak4619_Device_t *device, ak4619_WordLength_t wordLength);
uint8_t AK4619_GetDACWordLength(ak4619_Device_t *device, ak4619_WordLength_t *wordLength);
uint8_t AK4619_SetSystemClockSetting(ak4619_Device_t *device, ak4619_SystemClockSetting_t sysClock);
uint8_t AK4619_GetSystemClockSetting(ak4619_Device_t *device, ak4619_SystemClockSetting_t *sysClock);
uint8_t AK4619_SetADCVolumeTransitionTime(ak4619_Device_t *device, ak4619_DigitalVolumeTransitionTime_t tranTime);
uint8_t AK4619_GetADCVolumeTransitionTime(ak4619_Device_t *device, ak4619_DigitalVolumeTransitionTime_t *tranTime);
uint8_t AK4619_SetDACVolumeTransitionTime(ak4619_Device_t *device, ak4619_DigitalVolumeTransitionTime_t tranTime);
uint8_t AK4619_GetDACVolumeTransitionTime(ak4619_Device_t *device, ak4619_DigitalVolumeTransitionTime_t *tranTime);
uint8_t AK4619_SetADCSoftMuteSetting(ak4619_Device_t *device, ak4619_SoftMuteSetting_t softMute);
uint8_t AK4619_GetADCSoftMuteSetting(ak4619_Device_t *device, ak4619_SoftMuteSetting_t *softMute);
uint8_t AK4619_SetDACSoftMuteSetting(ak4619_Device_t *device, ak4619_SoftMuteSetting_t softMute);
uint8_t AK4619_GetDACSoftMuteSetting(ak4619_Device_t *device, ak4619_SoftMuteSetting_t *softMute);
uint8_t AK4619_SetADCDCBlockingFilter(ak4619_Device_t *device, ak4619_DCBlockingFilterMode_t hpf);
uint8_t AK4619_GetADCDCBlockingFilter(ak4619_Device_t *device, ak4619_DCBlockingFilterMode_t *hpf);
uint8_t AK4619_SetDACInputSource(ak4619_Device_t *device, ak4619_DACSourceSetting_t source);
uint8_t AK4619_GetDACInputSource(ak4619_Device_t *device, ak4619_DACSourceSetting_t *source);
uint8_t AK4619_SetDACDeemphasisFilter(ak4619_Device_t *device, ak4619_DeemphasisMode_t deemp);
uint8_t AK4619_GetDACDeemphasisFilter(ak4619_Device_t *device, ak4619_DeemphasisMode_t *deemp);
uint8_t AK4619_SetMicAmpGain(ak4619_Device_t *device, ak4619_Converter_t converter, ak4619_MicGainSetting_t micGain);
uint8_t AK4619_GetMicAmpGain(ak4619_Device_t *device, ak4619_Converter_t converter, ak4619_MicGainSetting_t *micGain);
uint8_t AK4619_SetDigitalVolume(ak4619_Device_t *device, ak4619_Converter_t converter, uint8_t volume[2]);
uint8_t AK4619_GetDigitalVolume(ak4619_Device_t *device, ak4619_Converter_t converter, uint8_t volume[2]);
uint8_t AK4619_SetAntiAliasingFilter(ak4619_Device_t *device, ak4619_Converter_t converter, ak4619_DigitalFilter_t aaFilter);
uint8_t AK4619_GetAntiAliasingFilter(ak4619_Device_t *device, ak4619_Converter_t converter, ak4619_DigitalFilter_t *aaFilter);
uint8_t AK4619_SetADCInputMode(ak4619_Device_t *device, ak4619_ADC_t adc, ak4619_AnalogInputMode_t inputMode);
uint8_t AK4619_GetADCInputMode(ak4619_Device_t *device, ak4619_ADC_t adc, ak4619_AnalogInputMode_t *inputMode);

/**
 * @}
 */

/**
 * @}
 */
